package mpegts

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func ExamplePAT_ParsePatSection() {
	data := []byte{
		0x00, 0xB0, 0x0D, 0x70, 0xE9, 0xDD, 0x00, 0x00,
		0x00, 0x01, 0xE0, 0x42, 0xAE, 0xF4, 0xD8, 0x1C,
	}

	pat := new(PAT)
	if err := pat.ParsePatSection(data); err != nil {
		panic(err)
	}

	fmt.Println("TSID", pat.TSID())
	for _, item := range pat.Items {
		fmt.Printf("Program Number %d PID %d\n", item.PNR(), item.PID())
	}

	// Output:
	// TSID 28905
	// Program Number 1 PID 66
}

func ExamplePAT_Packetize() {
	pat := NewPat()
	pat.SetVersion(1)
	pat.SetTSID(1)

	item := NewPatItem()
	item.SetPNR(1)
	item.SetPID(1031)
	pat.Items = append(pat.Items, item)

	pat.Finalize()

	ts := NewTS(0)
	_ = pat.Packetize(ts, func(data []byte) {
		// TS Header with Payload start offset
		fmt.Printf("%X...\n", data[:25])
	})

	// Output:
	// 474000100000B00D0001C300000001E407FF2D3E2FFFFFFFFF...
}

func TestPAT_ParsePatSection(t *testing.T) {
	assert := assert.New(t)

	data := []byte{
		0x00, 0xB0, 0x25, 0x00, 0x01, 0xC3, 0x00, 0x00,
		0x00, 0x00, 0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07,
		0x00, 0x02, 0xE4, 0x08, 0x00, 0x03, 0xE4, 0x09,
		0x00, 0x04, 0xE4, 0x0A, 0x00, 0x05, 0xE4, 0x0B,
		0x00, 0x06, 0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE,
	}

	expectedItems := []struct {
		pnr uint16
		pid uint16
	}{
		{pnr: 0, pid: 16},
		{pnr: 1, pid: 1031},
		{pnr: 2, pid: 1032},
		{pnr: 3, pid: 1033},
		{pnr: 4, pid: 1034},
		{pnr: 5, pid: 1035},
		{pnr: 6, pid: 1036},
	}

	pat := new(PAT)
	if err := pat.ParsePatSection(data); !assert.NoError(err) {
		return
	}

	assert.Equal(uint8(1), pat.Version())
	assert.Equal(uint16(1), pat.TSID())

	assert.Equal(7, len(pat.Items))

	for i, item := range pat.Items {
		expected := expectedItems[i]
		assert.Equal(expected.pnr, item.PNR())
		assert.Equal(expected.pid, item.PID())
	}
}

func TestPAT_Packetize(t *testing.T) {
	assert := assert.New(t)

	items := []struct {
		pnr uint16
		pid uint16
	}{
		{pnr: 0, pid: 16},
		{pnr: 1, pid: 1031},
		{pnr: 2, pid: 1032},
		{pnr: 3, pid: 1033},
		{pnr: 4, pid: 1034},
		{pnr: 5, pid: 1035},
		{pnr: 6, pid: 1036},
	}

	pat := NewPat()
	pat.SetVersion(1)
	pat.SetTSID(1)

	for _, item := range items {
		patItem := NewPatItem()
		patItem.SetPID(item.pid)
		patItem.SetPNR(item.pnr)
		pat.Items = append(pat.Items, patItem)
	}

	pat.Finalize()

	//

	// OC3.demo.ts
	expectedTS := []byte{
		0x47, 0x40, 0x00, 0x11, 0x00, 0x00, 0xB0, 0x25, 0x00, 0x01, 0xC3, 0x00,
		0x00, 0x00, 0x00, 0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07, 0x00, 0x02, 0xE4,
		0x08, 0x00, 0x03, 0xE4, 0x09, 0x00, 0x04, 0xE4, 0x0A, 0x00, 0x05, 0xE4,
		0x0B, 0x00, 0x06, 0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	}

	counter := 0
	ts := NewTS(0)
	ts.SetCC(1)
	err := pat.Packetize(ts, func(data []byte) {
		assert.Equal(expectedTS, data)
		counter += 1
	})
	assert.NoError(err)
	assert.Equal(1, counter)
}
