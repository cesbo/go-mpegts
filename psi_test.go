package mpegts

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

type TestData struct {
	assert          *assert.Assertions
	section         PSI
	expectedHandler bool
	expectedError   bool
}

var testPayload = []byte{
	0x00, 0xB0, 0x25, 0x00, 0x01, 0xC3, 0x00, 0x00,
	0x00, 0x00, 0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07,
	0x00, 0x02, 0xE4, 0x08, 0x00, 0x03, 0xE4, 0x09,
	0x00, 0x04, 0xE4, 0x0A, 0x00, 0x05, 0xE4, 0x0B,
	0x00, 0x06, 0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE,
}

func (t *TestData) onPSI(err error) {
	if t.expectedError {
		t.assert.Error(err, "expected error")
		return
	}

	if !t.assert.NoError(err, "unexpected error") {
		return
	}

	section := t.section
	buffer := section.Payload()

	t.assert.True(t.expectedHandler, "unexpected handler call")
	t.assert.Greater(len(buffer), 3+4, "buffer length should be at least 7 bytes")

	t.assert.Equal(uint8(0x00), section.TableID)
	t.assert.Equal(uint8(1), section.Version)
	t.assert.Equal(uint8(0), section.SectionNumber)
	t.assert.Equal(uint8(0), section.LastSectionNumber)
	t.assert.Equal(uint32(0xB2D1B8DE), section.CRC)

	t.assert.Equal(testPayload, buffer)
}

func (t *TestData) clear() {
	t.section.Clear()
	t.expectedHandler = true
	t.expectedError = false
}

func makePacket(data []byte) TS {
	p := NewTS(0)
	copy(p, data)
	return p
}

func Test_Assemble_1(t *testing.T) {
	test := TestData{
		assert: assert.New(t),
	}

	t.Run("TS without payload", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x00, 0x00, 0x10,
		})

		test.clear()
		test.expectedHandler = false
		test.section.Assemble(packet, test.onPSI)
	})

	t.Run("PSI begins after the pointer field", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x10,
			0,
			0x00, 0xB0, 0x25, 0x00, 0x01, 0xC3, 0x00, 0x00,
			0x00, 0x00, 0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07,
			0x00, 0x02, 0xE4, 0x08, 0x00, 0x03, 0xE4, 0x09,
			0x00, 0x04, 0xE4, 0x0A, 0x00, 0x05, 0xE4, 0x0B,
			0x00, 0x06, 0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE,
		})

		test.clear()
		test.section.Assemble(packet, test.onPSI)
	})

	t.Run("PSI with pointer field", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x10,
			8,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0x00, 0xB0, 0x25, 0x00, 0x01, 0xC3, 0x00, 0x00,
			0x00, 0x00, 0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07,
			0x00, 0x02, 0xE4, 0x08, 0x00, 0x03, 0xE4, 0x09,
			0x00, 0x04, 0xE4, 0x0A, 0x00, 0x05, 0xE4, 0x0B,
			0x00, 0x06, 0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE,
		})

		test.clear()
		test.section.Assemble(packet, test.onPSI)
	})

	t.Run("PSI in two packets. Second packet without payload start", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x10,
			173,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0x00, 0xB0, 0x25, 0x00, 0x01, 0xC3, 0x00, 0x00,
			0x00, 0x00,
		})

		test.clear()
		test.expectedHandler = false
		test.section.Assemble(packet, test.onPSI)

		packet = makePacket([]byte{
			0x47, 0x00, 0x00, 0x11,
			0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07, 0x00, 0x02,
			0xE4, 0x08, 0x00, 0x03, 0xE4, 0x09, 0x00, 0x04,
			0xE4, 0x0A, 0x00, 0x05, 0xE4, 0x0B, 0x00, 0x06,
			0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE,
		})

		test.expectedHandler = true
		test.section.Assemble(packet, test.onPSI)
	})

	t.Run("PSI in two packets. Second packet has payload start", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x10,
			173,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0x00, 0xb0, 0x25, 0x00, 0x01, 0xc3, 0x00, 0x00,
			0x00, 0x00,
		})

		test.clear()
		test.expectedHandler = false
		test.section.Assemble(packet, test.onPSI)

		packet = makePacket([]byte{
			0x47, 0x40, 0x00, 0x11,
			30,
			0xE0, 0x10, 0x00, 0x01, 0xE4, 0x07, 0x00, 0x02,
			0xE4, 0x08, 0x00, 0x03, 0xE4, 0x09, 0x00, 0x04,
			0xE4, 0x0A, 0x00, 0x05, 0xE4, 0x0B, 0x00, 0x06,
			0xE4, 0x0C, 0xB2, 0xD1, 0xB8, 0xDE,
			// next psi (incomplete)
			0x00, 0x00, 0xFF,
		})

		test.expectedHandler = true
		test.section.Assemble(packet, test.onPSI)
	})

	t.Run("only 1 byte after pointer field", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x30,
			181,  /* AF Size */
			0x00, /* AF with stuffing only */
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF,
			// payload
			0,
			0x00,
		})

		test.clear()
		test.expectedHandler = false
		test.section.Assemble(packet, test.onPSI)
	})
}

func Test_AssembleErrors(t *testing.T) {
	test := TestData{
		assert: assert.New(t),
	}

	t.Run("pointer field out of range", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x10, 200,
		})

		test.clear()
		test.expectedError = true
		test.section.Assemble(packet, test.onPSI)
	})

	t.Run("section length is too big", func(t *testing.T) {
		packet := makePacket([]byte{
			0x47, 0x40, 0x00, 0x10,
			0,
			0x00, 0x0F, 0xFF,
		})

		test.clear()
		test.expectedError = true
		test.section.Assemble(packet, test.onPSI)
	})
}
